/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java library project to get you started.
 * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
 * User Manual available at https://docs.gradle.org/6.8/userguide/building_java_projects.html
 */

plugins {
    // Apply the java-library plugin for API and implementation separation.
    // Provides support for building a Java library. 
    // (de) Also ein jar wird erstellt
    id 'java-library'
}

// --warning-mode=all // (all,fail,none,summary), summary ist default - diese prop in ~/.gradle/gradle.properties

// All extra properties must be defined through the "ext" namespace!
// oder so:
def JAR_BASENAME = "de.klst.orderx"
//def JAR_VERSION  = "1.1.0"
version = '1.1.0'

//compileJava.options.encoding = 'UTF-8' // sonst wird auf WIN Cp1252 genutzt
//compileTestJava.options.encoding = 'UTF-8'
// oder besser:
tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

repositories {
    // declare any Maven/Ivy/file repository here:
    /*
    	https://mvnrepository.com/repos/central
     */
	mavenCentral()
	
    /* Use JCenter for resolving dependencies: https://bintray.com/
    
		Bintray's JCenter is an up-to-date collection of all popular Maven OSS artifacts, 
		including artifacts published directly to Bintray.
		
		JCenter macht dicht (ab April 2021 nur noch read only), siehe
		https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/
    
     */
    jcenter()
}

/*
 Abhängigkeiten in Gradle folgen dem gleichen Format wie Maven. Abhängigkeiten sind wie folgt aufgebaut:

group:name:version

compile 'org.springframework:spring-core:4.3.1.RELEASE'

Eine alternative Syntax hierfür benennt jede Komponente der Abhängigkeit explizit wie folgt:

compile group: 'org.springframework', name: 'spring-core', version: '4.3.1.RELEASE'

 Manchmal haben Sie eine lokale JAR-Datei, die Sie Ihrem Gradle-Build als Abhängigkeit hinzufügen müssen. So können Sie das machen:

dependencies {
    compile files('path/local_dependency.jar') // deprecated syntax!
}

 */
dependencies {
    // This dependency is used internally, and not exposed to consumers on their own compile classpath.
//	testImplementation('org.hamcrest:hamcrest:2.2')
    // Use JUnit test framework.
    testImplementation 'junit:junit:4.13'
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.7.1")

    // This dependency is exported to consumers, that is to say found on their compile classpath.
	// used in marshaller:
	api('org.glassfish.jaxb:jaxb-runtime:2.3.3')
	// used in jaxb-runtime:
	api('com.sun.istack:istack-commons-runtime:3.0.11')
	// wg. Singleton:
	api('javax.inject:javax.inject:1')

    // Bsp. This dependency is used internally, and not exposed to consumers on their own compile classpath.
//    implementation 'com.google.guava:guava:29.0-jre'
}

//sourceSets.main.java.srcDirs += ['e-doc-commons/src/main/java']
sourceSets {

// am Anfang bei Configure project
	logger.info("configurations=$configurations") 
	logger.info("project=$project")
	logger.info("it=$it")

	sourceSets.each { srcSet ->
        println "sourceSet ["+srcSet.name+"]"
        print "-->Source directories: "+srcSet.allJava.srcDirs+"\n"
        print "-->Output directories: "+srcSet.output.classesDirs.files+"\n"
        print "-->Compile classpath:\n"
        srcSet.compileClasspath.files.each { 
            print "  "+it.path+"\n"
        }
        println ""
        if(srcSet.name=="main") {
        	srcSet.java.srcDirs += ['e-doc-commons/src/main/java']         	
        }
	}
}

/* archiveFileName	
 If the name has not been explicitly set, the pattern for the name is: 
 [archiveBaseName]-[archiveAppendix]-[archiveVersion]-[archiveClassifier].[archiveExtension]
 Examples: de.klst.orderx-api-1.1.0.jar de.klst.orderx-impl-1.1.0.jar

 excludes / includes // Set<String>, Default with java plugin: []
 The set of exclude/includes patterns.

Patterns may include:

    '*' to match any number of characters
    '?' to match any single character
    '**' to match any number of directories or files 
 */
task apiJar(type: Jar) {
    archiveBaseName = JAR_BASENAME
    archiveAppendix = "api"
//    archiveVersion = JAR_VERSION
    includeEmptyDirs = false
    from sourceSets.main.output
	// include / exclude patterns are relative to the root(s)
    includes = ["**/api/**"]
}

jar {
    archiveBaseName = JAR_BASENAME
    archiveAppendix = "impl"
    excludes = ["**/api/**"]
    
	// direkt nach clean wird hier nur MANIFEST.MF ausgegeben, daher doLast ...
	doLast {
		// Test: (die Einstellung aus .gradle/gradle.properties wird ignoriert)
		logger.quiet('An info log message which is always logged.')
		logger.error('An error log message.')
		logger.warn('A warning log message.')
		logger.lifecycle("A lifecycle info log message: logging.level=${logging.level}")
		logger.info('An info log message.')
		logger.debug('A debug log message.')
		logger.trace('A trace log message.') // Gradle never logs TRACE level logs
	
		logger.info("impl jar: source.each:")
		source.each { src ->
	        logger.info(""+src)
//	        println(src)
		}
	}
//	tasks.each { task ->
//        println "["+task+"]"
//	}
}

artifacts {
    archives apiJar
}